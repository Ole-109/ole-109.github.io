<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Japan Prefecture Signpost Trainer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="signpost_sticker.css" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
</head>
<body>

<div id="map"></div>

<!-- Sidebar -->
<div id="sidebar">
  <button id="closeSidebar" title="Close">&times;</button>
  <div id="sidebarContent">
    <h2 id="prefNameEn"></h2>
    <h3 id="prefNameJa"></h3>

    <div id="imageWrapper">
      <div id="imagePlaceholder">
        <div class="spinner" aria-hidden="true"></div>
        <div id="placeholderText">No image yet</div>
      </div>
      <img id="prefImage" src="" alt="Signpost sticker" />
    </div>

    <!-- Preview strip (non-interactive) -->
    <div id="imagePreviewWrapper">
      <div id="imagePreview"></div>
    </div>

    <div id="galleryControls">
      <button id="prevImage" title="Previous">◀ Prev</button>
      <button id="nextImage" title="Next">Next ▶</button>
    </div>
    <div id="galleryInfo"></div>
  </div>
</div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin="">
</script>

<script>
// -------------------------------
// Map init
// -------------------------------
const map = L.map('map', { minZoom: 6, maxZoom: 7}).setView([36.2, 138.0], 5);
L.tileLayer(
  "https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png",
  {
    subdomains: "abcd",
    attribution: "&copy; OpenStreetMap &copy; CARTO"
  }
).addTo(map);


function prefectureStyle(feature) { return { color: '#333', weight: 1, fillColor: '#88aaff', fillOpacity: 0.6 }; }
function highlightStyle() { return { weight: 2, color: '#000', fillOpacity: 0.8 }; }

// -------------------------------
// Sidebar open/close
// -------------------------------
function openSidebar() {
  const sidebar = document.getElementById('sidebar');
  sidebar.classList.remove('closing');
  sidebar.classList.add('open');
}
function closeSidebar() {
  const sidebar = document.getElementById('sidebar');
  sidebar.classList.remove('open');
  sidebar.classList.add('closing');
}
document.getElementById('closeSidebar').onclick = closeSidebar;

// -------------------------------
// Image gallery logic
// -------------------------------
function sanitizeKey(nameEn) {
  if (!nameEn) return '';
  return nameEn.trim().split(/\s+/)[0].toLowerCase().replace(/[^a-z0-9]/g, '');
}

// Probe a single URL -> Promise<boolean>
function probeImage(url) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
    // small cache-bust for probe to avoid stale 404 caches
    img.src = url + '?_probe=' + Date.now();
  });
}

// Build a candidate list and probe in parallel, return ordered unique URLs up to maxImages
async function loadImagesForKey(key, maxImages = 12) {
  if (!key) return [];
  const exts = ['png','jpg','jpeg','webp'];
  const candidates = [];

  // numbered files (images/<key>/1.ext ... )
  for (let i = 1; i <= maxImages; i++) {
    for (const ext of exts) {
      candidates.push({ url: `images/${key}/${i}.${ext}`, order: i * 10 + exts.indexOf(ext) });
    }
  }
  // fallback root images (images/<key>.ext)
  for (const ext of exts) {
    candidates.push({ url: `images/${key}.${ext}`, order: 9999 + exts.indexOf(ext) });
  }

  // Probe all candidates in parallel (Promise.allSettled). This is faster than sequential probing.
  const probes = await Promise.allSettled(candidates.map(c => probeImage(c.url)));

  // Collect successful URLs with their order
  const successes = [];
  for (let i = 0; i < probes.length; i++) {
    if (probes[i].status === 'fulfilled' && probes[i].value === true) {
      successes.push({ url: candidates[i].url, order: candidates[i].order, idx: i });
    }
  }

  if (successes.length === 0) return [];

  // Sort by order to keep numeric ordering (1..12) first, then root fallback
  successes.sort((a, b) => a.order - b.order || a.idx - b.idx);

  // Remove duplicates (if any) and return up to maxImages
  const out = [];
  const seen = new Set();
  for (const s of successes) {
    if (!seen.has(s.url)) {
      out.push(s.url);
      seen.add(s.url);
    }
    if (out.length >= maxImages) break;
  }
  return out;
}

// -------------------------------
// Preview strip update (deterministic slot layout)
// NOTE: THUMB_WIDTH and GAP must match values in your CSS
// -------------------------------
function updatePreviewStrip() {
  const preview = document.getElementById('imagePreview');
  const wrapper = document.getElementById('imagePreviewWrapper');

  preview.innerHTML = '';
  if (!currentGallery.urls || currentGallery.urls.length === 0) {
    preview.style.transform = 'translateX(0)';
    return;
  }

  const THUMB_WIDTH = 48;   // must match CSS width for thumbnails
  const GAP = 6;            // spacing between thumbs (matches CSS)
  const SLOT = THUMB_WIDTH + GAP;

  // Build thumbnails (lazy) and make them clickable
  currentGallery.urls.forEach((url, i) => {
    const img = document.createElement('img');
    img.src = url;
    img.alt = `preview ${i+1}`;
    img.loading = 'lazy';
    img.width = THUMB_WIDTH;
    img.height = THUMB_WIDTH;
    img.className = (i === currentGallery.idx) ? 'active' : '';
    img.onclick = () => {
      currentGallery.idx = i;
      showGalleryState();
    };
    preview.appendChild(img);
  });

  // Compute transform so that thumbnail at index `currentGallery.idx` is centered.
  const wrapperWidth = wrapper.clientWidth;
  const centerX = Math.round(wrapperWidth / 2 - THUMB_WIDTH / 2);
  const offset = centerX - currentGallery.idx * SLOT;
  preview.style.transform = `translateX(${offset}px)`;
}

// -------------------------------
// Show gallery state with main image
// -------------------------------
let currentGallery = {urls: [], idx: 0};

function showGalleryState() {
  const imgEl = document.getElementById('prefImage');
  const placeholder = document.getElementById('imagePlaceholder');
  const placeholderText = document.getElementById('placeholderText');
  const info = document.getElementById('galleryInfo');
  const wrapper = document.getElementById('imageWrapper');
  const padding = 20; // total padding in px

  if(!currentGallery.urls.length){
    imgEl.style.display='none';
    placeholder.style.display='flex';
    placeholderText.textContent = 'No images found. Add images to images/<prefkey>/ or images/<prefkey>.png';
    document.getElementById('imagePreview').innerHTML = '';
    document.getElementById('imagePreview').style.transform = 'translateX(0)';
    info.textContent = '';
    return;
  }

  // Show placeholder with "Loading..." while this single image loads
  placeholder.style.display='flex';
  placeholderText.textContent = 'Loading image...';
  imgEl.style.display='none';
  imgEl.style.opacity = 0;

  const url = currentGallery.urls[currentGallery.idx];

  // Load only this image immediately (preload via temp Image)
  const temp = new Image();
  temp.decoding = 'async';
  temp.onload = () => {
    // compute ratio and set size
    const wrapperWidth = wrapper.clientWidth - padding;
    const wrapperHeight = wrapper.clientHeight - padding;
    const ratio = Math.min(wrapperWidth / temp.naturalWidth, wrapperHeight / temp.naturalHeight);
    imgEl.width = Math.round(temp.naturalWidth * ratio);
    imgEl.height = Math.round(temp.naturalHeight * ratio);

    // set main src and fade in
    imgEl.src = url;
    imgEl.style.transition = 'opacity 0.35s ease-in-out';

    // hide placeholder and show image
    placeholder.style.display = 'none';
    imgEl.style.display = 'block';
    requestAnimationFrame(() => { imgEl.style.opacity = 1; });

    // update preview highlight after show
    updatePreviewStrip();
  };
  temp.onerror = () => {
    placeholder.style.display = 'flex';
    placeholderText.textContent = 'Failed to load image';
    imgEl.style.display = 'none';
  };
  // small cache-bust to ensure fresh load for this immediate display
  temp.src = url + '?_v=' + Date.now();

  info.textContent = `${currentGallery.idx+1} / ${currentGallery.urls.length}`;
}

// -------------------------------
// Background preloader
// Preloads remaining images with low priority (idle or setTimeout)
// -------------------------------
function backgroundPreload(urls, skipIndex=0) {
  const toPreload = urls.filter((u, i) => i !== skipIndex);
  if (toPreload.length === 0) return;

  const doPreload = () => {
    toPreload.forEach(u => {
      const img = new Image();
      img.decoding = 'async';
      // allow browser to prioritize cached loads; do not add cache-bust here
      img.src = u;
    });
  };

  if ('requestIdleCallback' in window) {
    requestIdleCallback(doPreload, { timeout: 2000 });
  } else {
    // degrade gracefully
    setTimeout(doPreload, 500);
  }
}

// -------------------------------
// Arrow handlers
// -------------------------------
document.getElementById('prevImage').onclick = ()=>{
  if(!currentGallery.urls.length) return;
  currentGallery.idx = (currentGallery.idx-1+currentGallery.urls.length)%currentGallery.urls.length;
  showGalleryState();
};
document.getElementById('nextImage').onclick = ()=>{
  if(!currentGallery.urls.length) return;
  currentGallery.idx = (currentGallery.idx+1)%currentGallery.urls.length;
  showGalleryState();
};

// -------------------------------
// Prefecture interaction
// -------------------------------
function onEachPrefecture(feature, layer) {
  layer.on({
    mouseover: (e) => e.target.setStyle(highlightStyle()),
    mouseout: (e) => prefectureLayer.resetStyle(e.target),

    click: async () => {
    const nameEn = feature.properties['name:en'] ?? 'Unknown';
    const nameJa = feature.properties['name:ja'] ?? '';
    const key = sanitizeKey(nameEn);

    // OPEN SIDEBAR IMMEDIATELY
    openSidebar();

    // Reset gallery + show placeholder
    currentGallery = { urls: [], idx: 0 };
    const preview = document.getElementById('imagePreview');
    preview.innerHTML = '';
    preview.style.transform = 'translateX(0)';
    const placeholder = document.getElementById('imagePlaceholder');
    const placeholderText = document.getElementById('placeholderText');
    placeholder.style.display = 'flex';
    placeholderText.textContent = 'Searching images...';
    document.getElementById('prefImage').style.display = 'none';
    document.getElementById('galleryInfo').textContent = '';

    // Load images
    const urls = await loadImagesForKey(key, 12);
    currentGallery.urls = urls;

    // NO IMAGES CASE
    if (urls.length === 0) {
        // Gray out region
        layer.setStyle({ fillColor: '#cccccc', fillOpacity: 0.6 });

        // Update sidebar
        document.getElementById('prefNameEn').innerText = 'No meta available';
        document.getElementById('prefNameJa').innerText = '';
        placeholderText.textContent = 'No images available';
        document.getElementById('imagePreview').innerHTML = '';
        document.getElementById('galleryInfo').textContent = '';
        return; // stop further processing
    }

    // IMAGES EXIST: restore normal color
    layer.setStyle(prefectureStyle(feature));

    // Show first image
    currentGallery.idx = 0;
    showGalleryState();

    // Build preview strip (thumbnails lazy-load)
    updatePreviewStrip();

    // Preload remaining images in background
    backgroundPreload(urls, 0);
}

  });
}


// -------------------------------
// Load GeoJSON
// -------------------------------
let prefectureLayer;
fetch('prefectures_land_only_clean.geojson')
  .then(res=>res.json())
  .then(data=>{
    prefectureLayer=L.geoJSON(data,{
      style: prefectureStyle,
      onEachFeature:onEachPrefecture,
      interactive:true,
      fill:true
    }).addTo(map);
    map.fitBounds(prefectureLayer.getBounds());
  }).catch(err=>console.error('GeoJSON load error:',err));
</script>
</body>
</html>
